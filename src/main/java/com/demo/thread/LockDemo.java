package com.demo.thread;

public class LockDemo {

    public static void main(String[] args) {
        //锁的分类
        //1.公平锁与非公平锁
        //公平锁指的是多个线程按照申请锁的顺序获取锁
        //非公平锁指的是多线程获取锁不是按照申请锁的顺序
        //对于ReentrantLock而言，可以通过构造函数将其定义为公平锁或者非公平锁
        //synchronized是非公平锁
        //非公平锁的有点是吞吐量比公平锁大

        //2.可重入锁
        //同一线程在外层方法获取锁时可以在内层方法自动获取锁。
        //ReentrantLock是一个可重入锁
        //synchronized也是可重入锁

        //3.独享锁和共享锁
        //独享锁指该锁一次只能被一个线程持有
        //共享锁指该锁一次可以被多个线程持有
        //Lock的实现ReentrantLock是一个独享锁，synchronized也是独享锁
        //Lock的另一个实现ReadWriteLock，其读锁是共享锁，写锁是独享锁
        //读写，写读，写写这些过程是互斥的

        //4.互斥锁和读写锁
        //互斥锁就是独享锁的具体实现,比如ReentrantLock,
        //读写锁就是共享锁的具体实现，比如ReadWriteLock

        //5.乐观锁和悲观锁
        //不是具体的锁，是看待并发的角度
        //乐观锁认为对于一个数据的并发操作不会发生并发修改,适合读操作场景
        //悲观锁认为对于一个数据的并发操作一定会发胜修改，适合写操作场景
        //悲观锁在java中的应用，就是利用各种锁
        //乐观锁在java中的应用，是无锁编程，最典型的就是原子类，通过CAS自旋实现原子操作的更新

        //6.分段锁
        //是一种锁的技术，不是一种具体的锁
        //ConcurrentHashMap就是分段锁的应用，其内部由一个个Segement组成，每一个
        //Segement都是一个ReentrantLock,当put时不是放在一个分段中，就是实现了并行插入
        //但是如果要统计size的话，需要获取所有的分段锁才能计算。
        //设计的目的时细化锁的粒度

        //7.偏向锁、轻量级锁、重量级锁
        //这三种锁指的是的锁的状态，并且是针对synchronized
        //偏向锁:指一段同步代码块一直被一个线程访问，那么该线程将自动获取锁，降低获取锁的代价。
        //轻量级锁：当锁为偏向锁时，被另一个线程锁访问，偏向锁会升级为轻量级锁，其他线程会通过自选的方式获取锁
        //不会阻塞，提高性能
        //重量级锁：当锁为轻量级锁时，另一个线程虽然是自旋，但自旋不会一直持续下去，当达到一定的自旋次数后，还没有
        //获取到锁就会进入阻塞，该锁膨胀为重量级锁，重量级锁会让其他申请的线程进入阻塞，降低性能。

        //8.自旋锁
        //自旋锁指尝试获取锁的线程不会立即阻塞，而是通过循环的方式获取锁，减少了线程上下文切换的消耗
        //但是同时提高对cpu的消耗


    }

    public static synchronized void setA(){
        //如果不是可重入锁的话,setB()可能不会被当前线程执行，造成死锁
        setA();
    }
    public static synchronized void setB(){

    }
}
